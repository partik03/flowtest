{"version":3,"sources":["/home/partik-singh/APITesting/build/cli.cjs","../src/cli/index.ts","../src/parsers/yaml.ts","../src/cli/commands/run.ts","../src/http/client.ts","../src/utils/response.ts","../src/utils/errors.ts","../src/utils/ui.ts","../src/core/runner.ts"],"names":["result","InteractiveCommand"],"mappings":"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","file":"/home/partik-singh/APITesting/build/cli.cjs","sourcesContent":[null,"import { InteractiveCommand } from 'interactive-commander';\nimport runCommand from './commands/run';\nimport { initCommand } from './commands/init';\n\nexport default new InteractiveCommand()\n  .name('apiflow')\n  .description('Code-first API testing framework')\n  .version('1.0.0')\n  .helpOption('-h, --help', 'Show help')\n  .addCommand(runCommand)\n","import { parse, stringify} from \"yaml\";\nimport { readFileSync } from \"fs\";\nimport { YamlConfig, VariableContext } from \"../types\";\n\nexport default class YamlParser {\n\n    private context: VariableContext;\n\n    constructor() {\n        this.context = {\n            variables: {},\n            timestamp: new Date().toISOString(),\n            random: {\n                string: (length = 10) => Math.random().toString(36).substring(2, 2 + length),\n                number: (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min,\n            },\n        };\n    }\n\n    parse(filePath: string): YamlConfig {\n        try {\n            const fileContent = readFileSync(filePath, 'utf8');\n            let parsed = parse(fileContent) as YamlConfig;\n\n            if(parsed.variables && Object.keys(parsed.variables).length > 0) {\n                this.context.variables = parsed.variables;\n            }\n\n            this.validateConfig(parsed);\n            return this.substituteVariables(parsed);\n        } catch (error) {\n            throw new Error(`${error}`);\n        }\n    }\n\n    stringify(config: YamlConfig): string {\n        return stringify(config);\n    }\n\n    private validateConfig(config: YamlConfig): void {\n        if (!config.name) {\n            throw new Error('Config must have a name');\n        }\n        if(!config.tests || !config.tests?.length) throw new Error('Config must have at least one test case');\n\n        config.tests.forEach((test, index) => {\n            if(!test.name) throw new Error(`Test case ${index + 1} must have a name`);\n            if(!test.request?.method || !test.request?.url) throw new Error(`Test case ${index + 1} must have a request method and url`);\n            if(!test.expect?.statusCode) throw new Error(`Test case ${index + 1} must have an expected status code`);\n\n            if(test.expect.statusCode < 100 || test.expect.statusCode >= 600) {\n                throw new Error(`Invalid status code: ${test.expect.statusCode} for test case ${index + 1}`);\n            }\n\n            if(test.expect.headers) {\n                Object.keys(test.expect.headers).forEach((key) => {\n                    if(typeof test.expect.headers[key] !== 'string' && typeof test.expect.headers[key] !== 'object') {\n                        throw new Error(`Invalid header value: ${test.expect.headers[key]} for test case ${index + 1}`);\n                    }\n                });\n            }\n\n            if(test.expect.body) {\n                if(typeof test.expect.body !== 'string' && typeof test.expect.body !== 'object') {\n                    throw new Error(`Invalid body value: ${test.expect.body} for test case ${index + 1}`);\n                }\n            }\n        });\n    }\n\n    private substituteVariables<T>(obj: T): T {\n        if (typeof obj === 'string') {\n            return this.substituteString(obj) as T;\n        }\n        // Handle null/undefined\n        if (obj === null || obj === undefined) {\n            return obj;\n        }\n        if (Array.isArray(obj)) {\n            return obj.map(item => this.substituteVariables(item)) as T;\n        }\n\n        // Handle objects\n        if (typeof obj === 'object') {\n            const result = {} as T;\n            for (const [key, value] of Object.entries(obj)) {\n                if (typeof value === 'string') {\n                    result[key as keyof T] = this.substituteString(value) as any;\n                } else if (typeof value === 'object' && value !== null) {\n                    result[key as keyof T] = this.substituteVariables(value);\n                } else {\n                    result[key as keyof T] = value as any;\n                }\n            }\n            return result\n        }\n\n        const result = {} as T;\n        for (const [key, value] of Object.entries(obj)) {\n            result[key as keyof T] = this.substituteVariables(value);\n        }\n        return result;\n    }\n    private substituteString(str: string): string {\n        if (!str.includes('{{')) {\n            return str;\n        }\n        return str.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n            console.log('Found variable:', match, 'path:', path);\n            \n            // Handle random.string(length)\n            if (path.startsWith('random.string')) {\n                console.log(\"random.string\", path);\n                \n                const lengthMatch = path.match(/random\\.string\\((\\d+)\\)/);\n                const length = lengthMatch ? parseInt(lengthMatch[1]) : 10;\n                return Math.random().toString(36).substring(2, length + 2);\n            }\n            \n            // Handle random.number(min,max)\n            if (path.startsWith('random.number')) {\n                console.log(\"random.number\", path);\n                \n                const numbersMatch = path.match(/random\\.number\\((\\d+),(\\d+)\\)/);\n                if (numbersMatch) {\n                    const min = parseInt(numbersMatch[1]);\n                    const max = parseInt(numbersMatch[2]);\n                    return String(Math.floor(Math.random() * (max - min + 1)) + min);\n                }\n            }\n\n            if (path.startsWith('saveAs:')) {\n                // Handle saveAs variable - we'll implement this later\n                return match;\n            }\n\n            const value = this.context.variables[path];\n            if (value === undefined) {\n                console.warn(`Variable ${path} not found`);\n                return match;\n            }\n            return String(value);\n        });\n    }\n}","import { YamlParser } from \"../../parsers\";\nimport { InteractiveCommand, InteractiveOption } from \"interactive-commander\";\nimport fs from 'fs';\nimport { runTests } from \"../../core\";\nimport { testSpinner } from \"../../utils/ui\";\n\nconst yamlParser = new YamlParser();\n\n\nexport default new InteractiveCommand()\n.command('run')\n.description('Run API tests')\n.argument('[file]', 'Path to the YAML file containing the test configuration')\n.action(async (filePath: string) => {\n    if(!filePath) {\n        console.error('No file path provided');\n        return;\n    }\n    if(!filePath.endsWith('.yaml') && !filePath.endsWith('.yml')) {\n        console.error('Invalid file type. Please provide a YAML file.');\n        return;\n    }\n    if(!fs.existsSync(filePath)) {\n        console.error(`File not found: ${filePath}`);\n        return;\n    }\n\n    try {\n        const config = yamlParser.parse(filePath);\n        testSpinner.succeed('Configuration loaded');\n\n        console.log(`\\n�� Running tests from: ${filePath}`);\n        await runTests(config);\n    } catch (error) {\n        console.error(`Error parsing YAML file: ${error}`);\n        return;\n    }\n     \n})\n\n","import axios, { AxiosRequestConfig } from 'axios';\nimport { HttpResponse, TestCase} from '../types';\nimport { handleSuccessResponse, handleErrorResponse } from '../utils/response';\nimport { ValidationError } from '../utils/errors';\nimport { requestSpinner } from '../utils/ui';\n\n\nexport async function executeRequest(test: TestCase, baseUrl: string): Promise<HttpResponse> {\n  const startTime = Date.now();\n\n  if(!test.request.method || !test.request.url) {\n    throw new ValidationError('Request method and URL are required');\n  }\n  \n  // Prepare request config\n  const config: AxiosRequestConfig = {\n    method: test.request.method,\n    url: `${baseUrl}${test.request.url}`,\n    headers: test.request.header,\n    data: test.request.body,\n    timeout: 5000, // Default timeout\n    validateStatus: (status) => status >= 200 && status < 600, // Accept all status codes\n  };\n\n  try {\n    // Log request details\n    requestSpinner.start(`🚀 Executing ${test.name}`);\n    requestSpinner.text = `${config.method} ${config.url}`;\n    if(config.headers) {\n        console.log('Headers:', config.headers);\n    }\n    if(config.data) {\n        console.log('Body:', config.data);\n    }\n    // Execute request\n    const response = await axios(config);\n    \n    // Calculate duration\n    const duration = Date.now() - startTime;\n\n    // Stop spinner with success\n    requestSpinner.succeed(`Completed ${test.name} in ${duration}ms`);\n\n    // Log response details\n    console.log(`Status: ${response.status}`);\n    console.log('Response:', JSON.stringify(response.data, null, 2));\n\n    // Return unified response format\n    return handleSuccessResponse(response, startTime);\n    // return {\n    //   statusCode: response.status,\n    //   statusText: response.statusText,\n    //   headers: response.headers as Record<string, string>,\n    //   body: response.data,\n    //   timestamp: new Date(),\n    //   statusMessage: response.statusText,\n    //   protoMajor: 1,\n    //   protoMinor: 1,\n    //   duration: duration\n    // };\n  } catch (error) {\n    requestSpinner.fail(`Failed ${test.name}`);\n    return handleErrorResponse(error, startTime);\n//     if (axios.isAxiosError(error)) {\n//       // Handle Axios errors\n//       return {\n//         statusCode: error.response?.status || 0,\n//         statusText: error.response?.statusText || 'Request failed',\n//         headers: error.response?.headers as Record<string, string> || {},\n//         body: error.response?.data || null,\n//         timestamp: new Date(),\n//         statusMessage: error.response?.statusText || 'Request failed',\n//         protoMajor: 1,\n//         protoMinor: 1,\n//       };\n//     }\n//     throw error; // Re-throw non-Axios errors\n//   }\n}}","import { AxiosResponse, AxiosError } from 'axios';\nimport { HttpResponse } from '../types';\nimport { \n  HTTPError, \n  NetworkError, \n  TimeoutError, \n  RequestError \n} from './errors';\n\nexport function handleSuccessResponse(\n  response: AxiosResponse,\n  startTime: number\n): HttpResponse {\n  const duration = Date.now() - startTime;\n  \n  return {\n    statusCode: response.status,\n    statusText: response.statusText,\n    statusMessage: response.statusText,\n    headers: response.headers as Record<string, string>,\n    body: response.data,\n    timestamp: new Date(),\n    protoMajor: 1,\n    protoMinor: 1,\n    duration\n  };\n}\n\nexport function handleErrorResponse(\n  error: unknown,\n  startTime: number\n): HttpResponse {\n  const duration = Date.now() - startTime;\n\n  if (error instanceof AxiosError) {\n    if (error.code === 'ECONNABORTED') {\n      throw new TimeoutError(5000); // Default timeout\n    }\n\n    if (error.code === 'ECONNREFUSED' || error.code === 'ENOTFOUND') {\n      throw new NetworkError(`Network error: ${error.message}`);\n    }\n\n    if (error.response) {\n      // Server responded with error status\n      throw new HTTPError(\n        error.response.status,\n        error.response.statusText,\n        error.response.data\n      );\n    }\n\n    if (error.request) {\n      // Request was made but no response received\n      throw new NetworkError('No response received from server');\n    }\n  }\n\n  // Handle unknown errors\n  throw new RequestError(\n    'An unexpected error occurred',\n    error\n  );\n}","export class APIFlowError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'APIFlowError';\n    }\n  }\n  \n  export class NetworkError extends APIFlowError {\n    constructor(message: string) {\n      super(message);\n      this.name = 'NetworkError';\n    }\n  }\n  \n  export class TimeoutError extends APIFlowError {\n    constructor(timeout: number) {\n      super(`Request timed out after ${timeout}ms`);\n      this.name = 'TimeoutError';\n    }\n  }\n  \n  export class ValidationError extends APIFlowError {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ValidationError';\n    }\n  }\n  \n  export class HTTPError extends APIFlowError {\n    constructor(\n      public statusCode: number,\n      public statusText: string,\n      public response?: unknown\n    ) {\n      super(`HTTP Error ${statusCode}: ${statusText}`);\n      this.name = 'HTTPError';\n    }\n  }\n  \n  export class RequestError extends APIFlowError {\n    constructor(message: string, public originalError?: unknown) {\n      super(message);\n      this.name = 'RequestError';\n    }\n  }","import ora from 'ora';\nimport ProgressBar from 'progress';\n\n// Spinner instances\nexport const testSpinner = ora({\n  text: 'Running tests',\n  color: 'cyan'\n});\n\nexport const requestSpinner = ora({\n  text: 'Executing request',\n  color: 'yellow'\n});\n\n// Progress bar for test suite\nexport function createTestProgressBar(total: number): ProgressBar {\n  return new ProgressBar('Running tests [:bar] :current/:total :percent :etas', {\n    complete: '█',\n    incomplete: ' ',\n    width: 30,\n    total\n  });\n}\n\n// Progress bar for request execution\nexport function createRequestProgressBar(): ProgressBar {\n  return new ProgressBar('Request progress [:bar] :percent :etas', {\n    complete: '█',\n    incomplete: ' ',\n    width: 20,\n    total: 100\n  });\n}","import { executeRequest } from '../http/client';\nimport { YamlConfig } from '../types';\nimport { testSpinner, createTestProgressBar } from '../utils/ui';\nimport { \n    APIFlowError, \n    HTTPError, \n    NetworkError, \n    TimeoutError, \n    ValidationError \n  } from '../utils/errors';\n\n\nexport default async function runTests(config: YamlConfig): Promise<void> {\n  try {\n    // Start test suite spinner\n    testSpinner.start('Loading test configuration');\n    testSpinner.succeed('Configuration loaded');\n\n\n    // Create progress bar for test suite\n    const progressBar = createTestProgressBar(config.tests.length);\n    \n    let passed = 0;\n    let failed = 0;\n\n    // Run each test\n    for (const test of config.tests) {\n      try {\n        console.log(`\\n🧪 Running test: ${test.name}`);\n\n        const result = await executeRequest(test, config.baseUrl || '');\n        progressBar.tick();\n        // Log test result\n        console.log(`\\n✅ Test \"${test.name}\" completed`);\n        console.log(`Duration: ${result.duration}ms`);\n        passed++;\n      } catch (error) {\n        progressBar.tick();\n        failed++;\n        if (error instanceof HTTPError) {\n            console.error(`\\n❌ Test \"${test.name}\" failed with HTTP error:`);\n            console.error(`Status: ${error.statusCode}`);\n            console.error(`Message: ${error.statusText}`);\n            if (error.response) {\n                console.error('Response:', error.response);\n            }\n        } else if (error instanceof NetworkError) {\n            console.error(`\\n❌ Test \"${test.name}\" failed with network error:`);\n            console.error(error.message);\n        } else if (error instanceof TimeoutError) {\n            console.error(`\\n❌ Test \"${test.name}\" failed with timeout:`);\n            console.error(error.message);\n        } else if (error instanceof ValidationError) {\n            console.error(`\\n❌ Test \"${test.name}\" failed validation:`);\n            console.error(error.message);\n        } else {\n            console.error(`\\n❌ Test \"${test.name}\" failed with unexpected error:`);\n            console.error(error);\n        }\n      }\n    }\n\n     // Print summary\n    console.log('\\n📊 Test Summary:');\n    console.log(`Total: ${config.tests.length}`);\n    console.log(`Passed: ${passed}`);\n    console.log(`Failed: ${failed}`);\n  } catch (error) {\n    testSpinner.fail('Test execution failed');\n    if (error instanceof APIFlowError) {\n        console.error('Test execution failed:', error.message);\n    } else {\n        console.error('Unexpected error during test execution:', error);\n    }\n    throw error;\n  }\n}"]}