{"version":3,"sources":["/home/partik-singh/APITesting/build/cli.cjs","../src/cli/index.ts","../src/parsers/yaml.ts","../src/cli/commands/run.ts"],"names":["result","InteractiveCommand"],"mappings":"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","file":"/home/partik-singh/APITesting/build/cli.cjs","sourcesContent":[null,"import { InteractiveCommand } from 'interactive-commander';\nimport runCommand from './commands/run';\nimport { initCommand } from './commands/init';\n\nexport default new InteractiveCommand()\n  .name('apiflow')\n  .description('Code-first API testing framework')\n  .version('1.0.0')\n  .helpOption('-h, --help', 'Show help')\n  .addCommand(runCommand)\n//   .addCommand('run')\n//   .description('Run API tests')\n//   .argument('[file]', 'Test file to run')\n//   .action(runCommand);\n\n// program\n//   .command('init')\n//   .description('Initialize a new test configuration')\n//   .action(initCommand);\n","import { parse, stringify} from \"yaml\";\nimport { readFileSync } from \"fs\";\nimport { YamlConfig, VariableContext } from \"../types/parsers/yaml\";\n\nexport default class YamlParser {\n\n    private context: VariableContext;\n\n    constructor() {\n        this.context = {\n            variables: {},\n            timestamp: new Date().toISOString(),\n            random: {\n                string: (length = 10) => Math.random().toString(36).substring(2, 2 + length),\n                number: (min: number, max: number) => Math.floor(Math.random() * (max - min + 1)) + min,\n            },\n        };\n    }\n\n    parse(filePath: string): YamlConfig {\n        try {\n            const fileContent = readFileSync(filePath, 'utf8');\n            let parsed = parse(fileContent) as YamlConfig;\n\n            if(parsed.variables && Object.keys(parsed.variables).length > 0) {\n                this.context.variables = parsed.variables;\n            }\n\n            this.validateConfig(parsed);\n            return this.substituteVariables(parsed);\n        } catch (error) {\n            throw new Error(`${error}`);\n        }\n    }\n\n    stringify(config: YamlConfig): string {\n        return stringify(config);\n    }\n\n    private validateConfig(config: YamlConfig): void {\n        if (!config.name) {\n            throw new Error('Config must have a name');\n        }\n        if(!config.tests || !config.tests?.length) throw new Error('Config must have at least one test case');\n\n        config.tests.forEach((test, index) => {\n            if(!test.name) throw new Error(`Test case ${index + 1} must have a name`);\n            if(!test.request?.method || !test.request?.url) throw new Error(`Test case ${index + 1} must have a request method and url`);\n            if(!test.expect?.statusCode) throw new Error(`Test case ${index + 1} must have an expected status code`);\n\n            if(test.expect.statusCode < 100 || test.expect.statusCode >= 600) {\n                throw new Error(`Invalid status code: ${test.expect.statusCode} for test case ${index + 1}`);\n            }\n\n            if(test.expect.header) {\n                Object.keys(test.expect.header).forEach((key) => {\n                    if(typeof test.expect.header[key] !== 'string' && typeof test.expect.header[key] !== 'object') {\n                        throw new Error(`Invalid header value: ${test.expect.header[key]} for test case ${index + 1}`);\n                    }\n                });\n            }\n\n            if(test.expect.body) {\n                if(typeof test.expect.body !== 'string' && typeof test.expect.body !== 'object') {\n                    throw new Error(`Invalid body value: ${test.expect.body} for test case ${index + 1}`);\n                }\n            }\n        });\n    }\n\n    private substituteVariables<T>(obj: T): T {\n        if (typeof obj === 'string') {\n            return this.substituteString(obj) as T;\n        }\n        // Handle null/undefined\n        if (obj === null || obj === undefined) {\n            return obj;\n        }\n        if (Array.isArray(obj)) {\n            return obj.map(item => this.substituteVariables(item)) as T;\n        }\n\n        // Handle objects\n        if (typeof obj === 'object') {\n            const result = {} as T;\n            for (const [key, value] of Object.entries(obj)) {\n                if (typeof value === 'string') {\n                    result[key as keyof T] = this.substituteString(value) as any;\n                } else if (typeof value === 'object' && value !== null) {\n                    result[key as keyof T] = this.substituteVariables(value);\n                } else {\n                    result[key as keyof T] = value as any;\n                }\n            }\n            return result;\n        }\n\n        const result = {} as T;\n        for (const [key, value] of Object.entries(obj)) {\n            result[key as keyof T] = this.substituteVariables(value);\n        }\n        return result;\n    }\n    private substituteString(str: string): string {\n        if (!str.includes('{{')) {\n            return str;\n        }\n        return str.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n            console.log('Found variable:', match, 'path:', path);\n            \n            // Handle random.string(length)\n            if (path.startsWith('random.string')) {\n                const lengthMatch = path.match(/random\\.string\\((\\d+)\\)/);\n                const length = lengthMatch ? parseInt(lengthMatch[1]) : 10;\n                return Math.random().toString(36).substring(2, length + 2);\n            }\n            \n            // Handle random.number(min,max)\n            if (path.startsWith('random.number')) {\n                const numbersMatch = path.match(/random\\.number\\((\\d+),(\\d+)\\)/);\n                if (numbersMatch) {\n                    const min = parseInt(numbersMatch[1]);\n                    const max = parseInt(numbersMatch[2]);\n                    return String(Math.floor(Math.random() * (max - min + 1)) + min);\n                }\n            }\n\n            if (path.startsWith('saveAs:')) {\n                // Handle saveAs variable - we'll implement this later\n                return match;\n            }\n\n            const value = this.context.variables[path];\n            if (value === undefined) {\n                console.warn(`Variable ${path} not found`);\n                return match;\n            }\n            return String(value);\n        });\n    }\n}","import YamlParser from \"../../parsers/yaml\";\nimport { InteractiveCommand, InteractiveOption } from \"interactive-commander\";\nimport fs from 'fs';\n\n\nconst yamlParser = new YamlParser();\n\n\nexport default new InteractiveCommand()\n.command('run')\n.description('Run API tests')\n.argument('[file]', 'Path to the YAML file containing the test configuration')\n.action(async (filePath: string) => {\n    if(!filePath) {\n        console.error('No file path provided');\n        return;\n    }\n    if(!filePath.endsWith('.yaml') && !filePath.endsWith('.yml')) {\n        console.error('Invalid file type. Please provide a YAML file.');\n        return;\n    }\n    if(!fs.existsSync(filePath)) {\n        console.error(`File not found: ${filePath}`);\n        return;\n    }\n\n    try {\n        const config = yamlParser.parse(filePath);\n        console.log(config.tests);\n        console.log(`Running tests from ${filePath}`);\n    } catch (error) {\n        console.error(`Error parsing YAML file: ${error}`);\n        return;\n    }\n    \n    \n})\n\n"]}